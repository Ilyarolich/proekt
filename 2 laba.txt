1. .NET Framework — программная платформа, выпущенная компанией Microsoft в 2002 году. Основой платформы является общеязыковая среда исполнения Common Language Runtime (CLR), которая подходит для разных языков программирования. Функциональные возможности CLR доступны в любых языках программирования, использующих эту среду.

2. Common Language Runtime (англ. CLR — общеязыковая исполняющая среда) — исполняющая среда для байт-кода CIL (MSIL), в которой компилируются программы, написанные на .NET-совместимых языках программирования (C#, Managed C++, Visual Basic .NET,F# и прочие). CLR является одним из основных компонентов пакета Microsoft .NET Framework.
Среда CLR является реализацией спецификации CLI (англ. Common Language Infrastructure), спецификации общеязыковой инфраструктуры компании Microsoft.
CLR компилирует код приложения на языке CIL (реализация компиляции которого компанией Microsoft называется MSIL) во время его исполнения, а также предоставляет MSIL-программам (а следовательно, и программам, написанным на языках высокого уровня, поддерживающих .NET Framework) доступ к библиотеке классов .NET Framework, или так называемой .NET FCL (англ. Framework Class Library).

3. Библиотека классов .NET Framework представляет собой библиотеку классов, интерфейсов и типов значений, которые обеспечивают доступ к функциональным возможностям системы. Она составляет основу для создания приложений, компонентов и элементов управления .NET Framework. Пространства имен и их категории в библиотеке классов перечислены в следующей таблице и подробно описаны в данном справочном руководстве. Пространства имен и категории упорядочены по частоте использования. Используемые чаще всего пространства имен перечислены в первую очередь. https://msdn.microsoft.com/ru-ru/library/gg145045(v=vs.110).aspx

4. Сборка является базовой структурной единицей в .NET, на уровне которой проходит контроль версий, развертывание и конфигурация приложения.

5. IL (Intermediate Language) - код, содержащий набор инструкций, не зависящих от платформы. Иными словами, после компиляции исходного кода он преобразуется не в код для какой-то определенной платформы, а в промежуточный код на языке IL.

6. JIT-компиляция (англ. Just-in-time compilation, компиляция «на лету»), динамическая компиляция (англ. dynamic translation) — технология увеличения производительности программных систем, использующих байт-код, путём компиляции байт-кода в машинный код или в другой формат непосредственно во время работы программы. Таким образом достигается высокая скорость выполнения по сравнению с интерпретируемым байт-кодом[1] (сравнивая с компилируемыми языками) за счёт увеличения потребления памяти (для хранения результатов компиляции) и затрат времени на компиляцию. JIT базируется на двух более ранних идеях, касающихся среды исполнения: компиляции байт-кода идинамической компиляции.

7. Common Type System (сокр. CTS, рус. Общая система типов) — часть .NET Framework, формальная спецификация, определяющая, как какой-либо тип (класс, интерфейс, структура, встроенный тип данных) должен быть определён для его правильного выполнения средой .NET. Кроме того, данный стандарт определяет, как определения типов и специальные значения типов представлены в компьютерной памяти. Целью разработки CTS было обеспечение возможности программам, написанным на различных языках программирования, легко обмениваться информацией. Как это принято в языках программирования, тип может быть описан как определение набора допустимых значений (например, «все целые от 0 до 10») и допустимых операций над этими значениями (например, сложение и вычитание).

8. Все остальные классы в .NET, даже те, которые мы сами создаем, а также базовые типы, такие как System.Int32, являются неявно производными от класса Object. Даже если мы не указываем класс Object в качестве базового, по умолчанию неявно класс Object все равно стоит на вершине иерархии наследования. Поэтому все типы и классы могут реализовать те методы, которые определены в классе System.Object.

9.-----

10. Сборки (assembly) бывают двух типов - приватные (private), которые использует только само приложение, и совместные(shared), использующиеся набором приложений. При приватных сборках приложение изолируется от внешнего воздействия программ и операционной системы, отпадает необходимость заботиться об уникальности имен в глобальном пространстве имен. Чтобы сделать сборку совместной, ее необходимо специальным образом собрать и присвоить ей строгое шифрованное имя.

11. Манифест сборки (assembly manifest) - это внутренняя часть сборки, которая позволяет ей быть самоописанной. Assembly manifest позволяет идентифицировать сборку, указывает файлы, которые включаются в реализацию сборки, описывает типы и ресурсы, используемые в сборке, указывает зависимости от других сборок, а также набор прав доступа, которые необходимы сборке для корректной работы. Эта информация используется во время выполнения для разрешения ссылок, проверку корректности версий, проверку целостности загруженных сборок.

12. GAC — это глобальный кэш сборок. В нем хранятся совместно используемые сборки. Обычно это каталог С:\Windows\Assembly\GAC. Этот каталог имеет определенную структуру, в котором хранятся подкаталоги, имена которых сгенерированы по определенному алгоритму. В GAC можно поместить только сборки со строгими именами. Для того, чтобы поместить сборку в GAC, используют специальный инструмент GACUtil.exe, который знает всю внутреннюю структуру GAC и может генерировать имена подкаталогов надлежащим образом. Регистрировать в GAC сборки необходимо для того, чтобы избежать конфликтов имен сборок. Приведем пример: две компании выпустили сборку и назвали ее одним именем Calculus. Если мы скопируем эту сборку в каталог, в котором уже находится сборка с таким же именем, то мы затрем сборку, которая ранее могла использоваться каким-то приложением. Это приложение с новой сборкой теперь работать не сможет. Решением этой проблемы будет регистрация этих двух сборок в GAC, в котором для каждой будет создан отдельный каталог.

13. Управляемый код (managed code) - это код, работающий в среде CLR. Содержит метаданные, в которых находится информация для среды выполнения - о типах, членах и ссылках, используемых в коде.
Неуправляемый код компилируется в машинный код и поэтому выполняется ОС напрямую. Следовательно, он обладает способностью делать повреждающие/сильные вещи. Управляемый код этого не делает. Так все работает, поэтому обычно это связано со старыми файлами, такими как .dlls

14. Простейшая программа на C# состоит из одного класса, содержащего один метод. Каждая программа на C# должна иметь по меньшей мере метод Main (c большой буквы). Данный метод часто называют точкой входа в программу. Несмотря на свою важность, Main не является ключевым словом. Поэтому вы можете использовать в своих программах переменную Main (впрочем, я надеюсь на ваше благоразумие).

15.Using – используется для подключения библиотек и выбора пространства имен

16.есть в лекции

17.bool
Byte
Sbyte
Short
Ushort
Int
Uint
Long
Ulong
Float
Double
Decimal
Char
String
Object

18. Есть в лекции

19.
•	Целочисленные типы (byte, sbyte, char, short, ushort, int, uint, long, ulong)
•	Типы с плавающей запятой (float, double)
•	Тип decimal
•	Тип bool
•	Перечисления enum
•	Структуры (struct)

20. В чем же между ними различия? Для этого надо понять организацию памяти в .NET. Здесь память делится на два типа: стек и куча (heap). Параметры и переменные метода, которые представляют типы значений, размещают свое значение в стеке. Стек представляет собой структуру данных, которая растет снизу вверх: каждый новый добавляемый элемент помещаются поверх предыдущего. Время жизни переменных таких типов ограничено их контекстом. Физически стек - это некоторая область памяти в адресном пространстве.
Когда программа только запускается на выполнение, в конце блока памяти, зарезервированного для стека устанавливается указатель стека. При помещении данных в стек указатель переустанавливается таким образом, что снова указывает на новое свободное место. При вызове каждого отдельного метода в стеке будет выделяться область памяти или фрейм стека, где будут храниться значения его параметров и переменных.
20
Основное различие между ссылочными и значимыми типами данных — смысл равенства и копирования.
Для значимых типов при копировании вы получаете новый экземпляр, содержащий копиизначений исходного экземпляра. Иными словами, экземпляры ведут себя как значения, например, как числа. Если вы скопировали значение, и изменили исходное значение, то эти изменения никак не отразятся на копии:
Point p1 = new Point(1, 2);
Point p2 = p1; // (1, 2)
p1.X = 100;
// p2.X всё ещё равно 1
Для ссылочных типов, копирование даёт вам новую ссылку на те же данные. Соответственно, если вы меняете объект ссылочного типа, то эти изменения становятся доступны по любой из ссылок на объект:
XElement e1 = new XElement("test") { Value = "hello" };
XElement e2 = e1;
e1.Value = "goodbye";
// e2.Value стало равно "goodbye"
Теперь, равенство. Одинаковые экземпляры типов-значений, не зависимо от того, являются ли они копиями одного общего объекта или нет, являются равными. Экземпляры ссылочных типов, даже если они содержат одинаковые данные, являются разными.
Point p1 = new Point(1, 2), p2 = new Point(1, 2);
// p1 == p2
XElement e1 = new XElement("test") { Value = "hello" },
         e2 = new XElement("test") { Value = "hello" };
// e1 != e2
Можно сказать, что объекты ссылочных типов обладают индивидуальностью, а объекты значимых типов — нет.
________________________________________
Разумеется, семантику сравнения можно кастомизировать, перегрузив оператор сравнения (и/или реализовав интерфейс IEquatable<T>). При этом можно, например, заставить ссылочный тип вести себя так, как будто бы он является значимым типом. И наоборот, храня данные значимого типа в неизменяемом поле ссылочного типа, можно заставить значимый тип вести себя как ссылочный.
________________________________________
Все остальные отличия являются лишь следствиями этих, главных отличий. То, что переменные ссылочного типа в Майкрософтовской реализации хранят внутри ссылку, есть по сути деталь имплементации. То, что экземпляры значимых типов иногда попадают на стек (а именно, когда они не являются полями классов, и не лежат в замыкании, async-методе или методе-генераторе), также является деталью имплементации (и может быть не так в будущих версиях или другой имплементации платформы .NET).
________________________________________
Если вы выбираете, использовать для вашего объекта структуру (значимый тип) или класс (ссылочный тип), задайте себе вопрос: являются ли два объекта с одинаковыми данными одним и тем же, или разными? Если это, к примеру, объекты, представляющие человека, и в данных у вас его имя, фамилия и возраст, то имеет смысл использовать класс: ведь два человека с одинаковыми именами всё ещё не являются одним и тем же человеком.
А если это, например, объект, представляющий рациональную дробь, то нету смысла разделять различные экземпляры дроби 3/8, так что тут уместно воспользоваться структурой.
21.Что такое упаковка и распаковка значимых типов?
Что такое boxing (боксинг) 

Boxing или упаковка — это процесс, при котором значимый экземпляр из стека (то есть структура) попадает в управляемую кучу или, проще говоря, структура становится классом. Для этого производится полное копирование всего содержимого (поля, методы, свойства, значения) объекта с значимым типом в новый объект ссылочного типа. Эти два объекта никак не связаны между собой - если изменить структуру, то созданный объект останется неизменным. И наоборот. 

Процесс переноса содержимого структуры в новый объект занимает достаточно продолжительное время, поэтому его лучше избегать. 

Так как же происходит упаковка ? 

Упаковка или боксинг (boxing) происходит скрытно и без лишних вопросов. Программист, скорее всего, не заметит этого. Поэтому, если вам кажется, что в вашем проекте вы ничего не упаковываете, то, скорее всего вы не правы. 

Простенький пример 

1
int messageId = 146;
2
String.Format("Message with Id {0} was sent", messageId);


messageId – это переменная с целочисленным значением, то есть int. В свою очередь int — это структура, а структура это тип, доступный по значению. Если посмотреть на метод String.Format, он принимает string, params object[]. Вот оно! Переменная messageId будет упакована в object.


Распаковка, unboxing 
Если прикинуться капитаном — то можно дать очевидный ответ: распаковка это обратный процесс упаковки. Другими словами, в результате распаковки объект ссылочного типа преобразуется в значимый экземпляр, который будет помещен в стек. Созданный значимый экземпляр никаким образом не будет связан с ссылочным объектом. Процесс распаковки тоже достаточно длительный процесс, копируется все содержимое ссылочного объекта. 

Explicit и implicit 
Когда вы бодро и уверенно рассказали о упаковке и распаковке, скорее всего, вас спросят о том, что такое implicit и explicit. Это просто: explicit – явное преобразование, а implicit, наоборот, неявное. Как это выглядит в коде: 

1
int i = 146;
2
//implicit
3
object o = i;


1
int i = 146;
2
//explicit
3
object o = (object)i;


Отличия упаковки (распаковки) и преобразования типов 
Как мы уже поняли, упаковка и распаковка, по определению - это процесс, связанный только с значимыми типами (value-type или структуры). Если вы хотите выполнить преобразование экземпляра ссылочного типа Foo в обобщенный тип object – то это называется преобразование типов.
22.Для чего используется тип dynamic?
Ключевым моментом использования DLR в C# является применение типов dynamic. Это ключевое слово позволяет опустить проверку типов во время компиляции. Кроме того, объекты, объявленные как dynamic, могут в течение работы программы менять свой тип.

23.Что такое неявно типизированная переменная?

Локальные переменные можно объявлять без указания конкретного типа. Ключевое слово varуказывает, что компилятор должен вывести тип переменной из выражения справа от оператора инициализации. Выведенный тип может быть встроенным, анонимным, определяемым пользователем либо типом, определяемым в библиотеке классов .NET Framework.

24.Для чего используют Nullable тип?

"Nullable типы" - типы, включающие весь диапазон значений базового типа + null. В С++ часто возникает необходимость помимо численно результата вычислений возвращать еще и результат выполнения самой функции, т.е. удачно ли прошла операция, валидно ли вычисленное значение. Хорошо, если заранее известно, что результат вычисления не может быть равен нулю или не может быть отрицательным, тогда ошибку будут сигнализировать именно запрещенные значения результата. Однако когда результат покрывает все значения типа, приходится вводить дополнительные параметры к функции, специально сигнализирующие об ошибке. В C# эту проблему решают Nullable типы.

Обозначается nullable тип очень легко: после названия регулярного типа ставится "?", по сути этим знаком к диапазону значений базового типа прибавляется null. Вот так можно использовать nullable int для функции преобразования строки в число:

public static int? ToNullableInt32(string s)
{
   int i;
   if (Int32.TryParse(s, out i))  {
      return i;
   }
   return null;
}

25.Как объявить строковый литерал? Какие операции можно выполнять со строкой?

Литералы представляют неизменяемые значения (иногда их еще называют константами). Литералы можно передавать переменным в качестве значения. Литералы бывают логическими, целочисленными, вещественными, символьными и строчными. И отдельный литерал представляет ключевое слово null.
Логические литералы
Есть две логических константы - true (истина) и false (ложь):
1
2	Console.WriteLine(true);
Console.WriteLine(false);
Целочисленные литералы
Целочисленные литералы представляют положительные и отрицательные целые числа, например, 1, 2, 3, 4, -7, -109. Целочисленные литералы могут быть выражены в десятичной, шестнадцатеричной и двоичной форме.
С целыми числами в десятичной форме все должно быть понятно, так как они используются в повседневной жизни:
1
2
3	Console.WriteLine(-11);
Console.WriteLine(5);
Console.WriteLine(505);
Числа в двоичной форме предваряются символами 0b, после которых идет набор из нулей и единиц:
1
2
3	Console.WriteLine(0b11);        // 3
Console.WriteLine(0b1011);      // 11
Console.WriteLine(0b100001);    // 33
Для записи числа в шестнадцатеричной форме применяются символы 0x, после которых идет набор символов от 0 до 9 и от A до F, которые собственно представляют число:
1
2
3	Console.WriteLine(0x0A);    // 10
Console.WriteLine(0xFF);    // 255
Console.WriteLine(0xA1);    // 161
Вещественные литералы
Вещественные литералы представляют вещественные числа. Этот тип литералов имеет две формы. Первая форма - вещественные числа с фиксированной запятой, при которой дробную часть отделяется от целой части точкой. Например:
1
2
3	3.14
100.001
-0.38
Также вещественные литералы могут определяться в экспоненциальной форме MEp, где M — мантисса, E - экспонента, которая фактически означает "*10^" (умножить на десять в степени), а p — порядок. Например:
1
2	Console.WriteLine(3.2e3);   // по сути равно 3.2 * 10<sup>3</sup> = 3200
Console.WriteLine(1.2E-1);  // равно 1.2 * 10<sup>-1</sup> = 0.12
Символьные литералы
Символьные литералы представляют одиночные символы. Символы заключаются в одинарные кавычки.
Символьные литералы бывают нескольких видов. Прежде всего это обычные символы:
1
2
3	'2'
'A'
'T'
Специальную группу представляют управляющие последовательности Управляющая последовательность представляет символ, перед которым ставится обратный слеш. И данная последовательность интерпретируется определенным образом. Наиболее часто используемые последовательности:
•	'\n' - перевод строки
•	'\t' - табуляция
•	'\' - обратный слеш
И если компилятор встретит в тексте последовательность \t, то он будет воспринимать эту последовательность не как слеш и букву t, а как табуляцию - то есть длинный отступ.
Также символы могут определяться в виде шестнадцатеричных кодов, также заключенный в одинарные кавычки.
Еще один способ определения символов представляет использования шестнадцатеричных кодов ASCII. Для этого в одинарных кавычках указываются символы '\x', после которых идет шестнадцатеричный код символа из таблицы ASCII. Коды символов из таблицы ASCII можно посмотреть здесь.
Например, литерал '\x78' представляет символ "x":
1
2	Console.WriteLine('\x78');    // x
Console.WriteLine('\x5A');    // Z
И последний способ определения символьных литералов представляет применение кодов из таблицы символов Unicode. Для этого в одинарных кавычках указываются символы '\u', после которых идет шестнадцатеричный код Unicode. Например, код '\u0411' представляет кириллический символ 'Б':
1
2	Console.WriteLine('\u0420');    // Р
Console.WriteLine('\u0421');    // С
Строковые литералы
Строковые литералы представляют строки. Строки заключаются в двойные кавычки:
1
2
3	Console.WriteLine("hello");
Console.WriteLine("фыва");
Console.WriteLine("hello word");
Если внутри строки необходимо вывести двойную кавычку, то такая внутренняя кавычка предваряется обратным слешем:
1	Console.WriteLine("Компания \"Рога и копыта\"");
Также в строках можно использовать управляющие последовательности. Например, последовательность '\n' осуществляет перевод на новую строку:
1	Console.WriteLine("Привет \nмир");
При выводе на консоль слово "мир" будет перенесено на новую строку:
Привет
мир
null
null представляет ссылку, которая не указывает ни на какой объект. То есть по сути отсутствие значения.
26.Какие есть способы для задания и инициализации строк?

В языке C# строковые значения представляет тип string, а вся функциональность работы с данным типом сосредоточена в классеSystem.String. Собственно string является псевдонимом для класса System.String. Объекты этого класса представляют текст как последовательность символов Unicode. Максимальный размер объекта String может составлять в памяти 2 ГБ, или около 1 миллиарда символов.
Создание строк
Создавать сроки можно, как используя переменную типа string и присваивая ей значение, так и применяя один из конструкторов класса String:
1
2
3
4
5	string s1 = "hello";
string s2 = null;
 
string s3 = new String('a', 6); // результатом будет строка "aaaaaa"
string s4 = new String(new char[]{'w', 'o', 'r', 'l', 'd'});
Конструктор String имеет различное число версий. Так, вызов конструктора new String('a', 6) создаст строку "aaaaaa". И так как строка представляет ссылочный тип, то может хранить значение null.
Строка как набор символов
Так как строка хранит коллекцию символов, в ней определен индексатор для доступа к этим символам:
1	public char this[int index] {get;}
Применяя индексатор, мы можем обратиться к строке как к массиву символов и получить по индексу любой из ее символов:
1
2
3
4	string s1 = "hello";
char ch1 = s1[1]; // символ 'e'
Console.WriteLine(ch1);
Console.WriteLine(s1.Length);
Используя свойство Length, как и в обычном массиве, можно получить длину строки.
27.Какие методы есть у типа String?
Основные методы строк
Основная функциональность класса String раскрывается через его методы, среди которых можно выделить следующие:
•	Compare: сравнивает две строки с учетом текущей культуры (локали) пользователя
•	CompareOrdinal: сравнивает две строки без учета локали
•	Contains: определяет, содержится ли подстрока в строке
•	Concat: соединяет строки
•	CopyTo: копирует часть строки или всю строку в другую строку
•	EndsWith: определяет, совпадает ли конец строки с подстрокой
•	Format: форматирует строку
•	IndexOf: находит индекс первого вхождения символа или подстроки в строке
•	Insert: вставляет в строку подстроку
•	Join: соединяет элементы массива строк
•	LastIndexOf: находит индекс последнего вхождения символа или подстроки в строке
•	Replace: замещает в строке символ или подстроку другим символом или подстрокой
•	Split: разделяет одну строку на массив строк
•	Substring: извлекает из строки подстроку, начиная с указанной позиции
•	ToLower: переводит все символы строки в нижний регистр
•	ToUpper: переводит все символы строки в верхний регистр
•	Trim: удаляет начальные и конечные пробелы из строки
28.В чем отличие пустой и null строки?
Пустая строка — экземпляр объекта System.String, содержащий 0 символов: string s = ""; Для пустых строк можно вызывать методы. > Строки со значениями null не ссылаются на экземпляр объекта System.String, попытка вызвать метод для строки null вызовет исключение NullReferenceException. строки null можно использовать в операциях объединения и сравнения с другими строками.

29.Как можно выполнить сравнение строк?

Сравнение строк
Для сравнения строк применяется статический метод Compare:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17	string s1 = "hello";
string s2 = "world";
 
int result = String.Compare(s1, s2);
if (result<0)
{
    Console.WriteLine("Строка s1 перед строкой s2");
}
else if (result > 0)
{
    Console.WriteLine("Строка s1 стоит после строки s2");
}
else
{
    Console.WriteLine("Строки s1 и s2 идентичны");
}
// результатом будет "Строка s1 перед строкой s2"
Данная версия метода Compare принимает две строки и возвращает число. Если первая строка по алфавиту стоит выше второй, то возвращается число меньше нуля. В противном случае возвращается число больше нуля. И третий случай - если строки равны, то возвращается число 0.
В данном случае так как символ h по алфавиту стоит выше символа w, то и первая строка будет стоять выше.
30.В чем отличие типов String и StringBuilder
Данные, хранящиеся в классе System.String и есть неизменяемые (immutable). Класс System.StringBuilder разрабатывался так, чтобы над изменяемой строкой можно было проделать множество операций. То есть при каждой операции над объектом класса System.String происходит перенос данных в новую область памяти, что влияет на производительность программы.
Любые модификации строки происходят внутри блока памяти ? Length - длина строки ? Capacity - максимальная длина строки,

Хотя класс System.String предоставляет нам широкую функциональность по работе со строками, все таки он имеет свои недостатки. Прежде всего, объект String представляет собой неизменяемую строку. Когда мы выполняем какой-нибудь метод класса String, система создает новый объект в памяти с выделением ему достаточного места. Удаление первого символа - не самая затратная операция. Однако когда подобных операций множество, а объем текста, для которого надо выполнить данные операции, также не самый маленький, то издержки при потере производительности становятся более существенными.
Чтобы выйти из этой ситуации во фреймворк .NET был добавлен новый класс StringBuilder, который находится в пространстве именSystem.Text. Этот класс представляет динамическую строку.
При создании строки StringBuilder выделяет памяти больше, чем необходимо этой строке.
31.Поясните явные преобразования переменных с помощью команд Convert
32.Как выполнить консольный ввод/вывод?
Консольный вывод
Для вывода информации на консоль мы уже использовали встроенный метод Console.WriteLine. То есть, если мы хотим вывести некоторую информацию на консоль, то нам надо передать ее в метод Console.WriteLine:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18	using System;
 
namespace HelloApp
{
    class Program
    {
        static void Main(string[] args)
        {
            string hello = "Привет мир";
            Console.WriteLine(hello);
            Console.WriteLine("Добро пожаловать в C#!");
            Console.WriteLine("Пока мир...");
            Console.WriteLine(24.5);
             
            Console.ReadKey();
        }
    }
}
Консольный вывод:
Привет мир!
Добро пожаловать в C#!
Пока мир...
24,5
Нередко возникает необходимость вывести на консоль в одной строке значения сразу нескольких переменных. В этом случае мы можем использовать прием, который называется интерполяцией:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17	using System;
 
namespace HelloApp
{
    class Program
    {
        static void Main(string[] args)
        {
            string name = "Tom";
            int age = 34;
            double height = 1.7;
            Console.WriteLine($"Имя: {name}  Возраст: {age}  Рост: {height}м");
 
            Console.ReadKey();
        }
    }
}
Для встраивания отдельных значений в выводимую на консоль строку используются фигурные скобки, в которые заключается встраиваемое значение. Это можем значение переменной ({name}) или более сложное выражение (например, операция сложения {4 + 7}). А перед всей строкой ставится знак доллара $.
При выводе на консоль вместо помещенных в фигурные скобки выражений будут выводиться их значения:
Имя: Tom  Возраст: 34  Рост: 1,7м
Есть другой способ вывода на консоль сразу нескольких значений:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17	using System;
 
namespace HelloApp
{
    class Program
    {
        static void Main(string[] args)
        {
            string name = "Tom";
            int age = 34;
            double height = 1.7;
            Console.WriteLine("Имя: {0}  Возраст: {2}  Рост: {1}м", name, height, age);
 
            Console.ReadKey();
        }
    }
}
Этот способ подразумевает, что первый параметр в методе Console.WriteLine представляет выводимую строку ("Имя: {0} Возраст: {2} Рост: {1}м"). Все последующие параметры представляют значения, которые могут быть встроенны в эту строку (name, height, age). При этом важен порядок подобных параметров. Например, в данном случае вначале идет name, потом height и потом age. Поэтому у name будет представлять параметр с номером 0 (нумерация начинается с нуля), height имеет номер 1, а age - номер 2. Поэтому в строке "Имя: {0} Возраст: {2} Рост: {1}м" на место плейсхолдеров {0}, {2}, {1} будут вставляться значения соответствующих параметров.
Кроме Console.WriteLine() можно также использовать метод Console.Write(), он работает точно так же за тем исключением, что не осуществляет переход на следующую строку.
Консольный ввод
Кроме вывода информации на консоль мы можем получать информацию с консоли. Для этого предназначен метод Console.ReadLine(). Он позволяет получить введенную строку.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16	using System;
 
namespace HelloApp
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.Write("Введите свое имя: ");
            string name = Console.ReadLine();
            Console.WriteLine($"Привет {name}");
 
            Console.ReadKey();
        }
    }
}
В данном случае все, что вводит пользователь, с помощью метода Console.ReadLine передается в переменную name.
Пример работы программы:
Введите свое имя: Том
Привет Том
Таким образом мы можем вводить информацию через консоль. Однако минусом этого метода является то, что Console.ReadLine считывает информацию именно в виде строки. Поэтому мы можем по умолчанию присвоить ее только переменной типа string. Как нам быть, если, допустим, мы хотим ввести возраст в переменную типа int или другую информацию в переменные типа double или decimal? По умолчанию платформа .NET предоставляет ряд методов, которые позволяют преобразовать различные значения к типам int, double и т.д. Некоторые из этих методов:
•	Convert.ToInt32() (преобразует к типу int)
•	Convert.ToDouble() (преобразует к типу double)
•	Convert.ToDecimal() (преобразует к типу decimal)
Пример ввода значений:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26	using System;
 
namespace HelloApp
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.Write("Введите имя: ");
            string name = Console.ReadLine();
 
            Console.Write("Введите возраст: ");
            int age = Convert.ToInt32(Console.ReadLine());
 
            Console.Write("Введите рост: ");
            double height = Convert.ToDouble(Console.ReadLine());
 
            Console.Write("Введите размер зарплаты: ");
            decimal salary = Convert.ToDecimal(Console.ReadLine());
 
            Console.WriteLine($"Имя: {name}  Возраст: {age}  Рост: {height}м  Зарплата: {salary}$");
 
            Console.ReadKey();
        }
    }
}
При вводе важно учитывать текущую операционную систему. В одних культурах разделителем между целой и дробной частью является точка (США, Великобритания...), в других - запятая (Россия, Германия...). Например, если текущая ОС - русскоязычная, значит, надо вводить дробные числа с разделителем запятой. Если локализация англоязычная, значит, разделителем целой и дробной части при вводе будет точка.
Пример работы программы:
Введите имя: Том
Введите возраст: 25
Введите рост: 1,75
Введите размер зарплаты: 300,67
Имя: Том  Возраст: 25  Рост: 1,75м  Зарплата: 300,67$
33. Приведите примерны определения и инициализации одномерных и двумерных массивов.


Одномерные массивы (single-dimensional)
 тип[] имя;
 тип[] имя = new тип [ размерность ];
 тип[] имя = { список инициализаторов }; 
тип[] имя = new тип [] { список инициализаторов }; 
тип[] имя = new тип [ размерность ] { список инициализаторов };

 

Прямоугольные (многомерные) массивы 
тип[,] имя; тип[,] имя = new тип [ разм_1, разм_2 ]; 
тип[,] имя = { список инициализаторов }; 
тип[,] имя = new тип [,] { список инициализаторов }; 
тип[,] имя = new тип [ разм_1, разм_2 ] { список инициализаторов };

 
34. Что такое ступенчатый массив? Как его задать?

Массив массивов
От многомерных массивов надо отличать массив массивов или так называемый "зубчатый массив":
1
2
3
4	int[][] nums = new int[3][];
nums[0] = new int[2] { 1, 2 };          // выделяем память для первого подмассива
nums[1] = new int[3] { 1, 2, 3 };       // выделяем память для второго подмассива
nums[2] = new int[5] { 1, 2, 3, 4, 5 }; // выделяем память для третьего подмассива
Здесь две группы квадратных скобок указывают, что это массив массивов, то есть такой массив, который в свою очередь содержит в себе другие массивы. В данном случае у нас массив nums содержит три массива. Причем размерность каждого из этих массивов может не совпадать.
Зубчатый массив nums
1	2
1	2	3
1	2	3	4	5
Причем мы можем использовать в качестве массивов и многомерные:
1
2
3
4
5
6	int[][,] nums = new int[3][,] 
{
    new int[,] { {1,2}, {3,4} },
    new int[,] { {1,2}, {3,6} },
    new int[,] { {1,2}, {3,5}, {8, 13} } 
};
35. Какие типы можно использовать в foreach? Как его задать?

Массивы, коллекции. Классы в которых реализован интерфейс System.Collections.IEnumerable.

int[,] mas = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 }, { 10, 11, 12 } };
foreach (int i in mas)
    Console.Write($"{i} ");
Console.WriteLine();
36. Что такое кортеж? Для чего и как он используется?

Кортежи предоставляют удобный способ для работы с набором значений, который был добавлен в версии C# 7.0.
Кортеж представляет набор значений, заключенных в круглые скобки:
1	var tuple = (5, 10);
В данном случае определен кортеж tuple, который имеет два значения: 5 и 10. В дальнейшем мы можем обращаться к каждому из этих значений через поля с названиями Item[порядковый_номер_поля_в_кортеже]. Например:
1
2
3
4
5
6
7
8
9	static void Main(string[] args)
{
    var tuple = (5, 10);
    Console.WriteLine(tuple.Item1); // 5
    Console.WriteLine(tuple.Item2); // 10
    tuple.Item1 += 26;
    Console.WriteLine(tuple.Item1); // 31
    Console.Read();
}
В данном случае тип определяется неявно. Но мы ткже можем явным образом указать для переменной кортежа тип:
1	(int, int) tuple = (5, 10);
Так как кортеж содержит два числа, то в определении типа нам надо указать два числовых типа. Или другой пример определения кортежа:
1	(string, int, double) person = ("Tom", 25, 81.23);
Первый элемент кортежа в данном случае представляет строку, второй элемент - тип int, а третий - тип double.
Мы также можем дать названия полям кортежа:
1
2
3	var tuple = (count:5, sum:10);
Console.WriteLine(tuple.count); // 5
Console.WriteLine(tuple.sum); // 10
Теперь чтобы обратиться к полям кортежа используются их имена, а не названия Item1 и Item2.
Мы даже можем не использовать переменную для определения всего кортежа, а использовать отдельные переменные для его полей:
1
2
3
4
5
6
7	static void Main(string[] args)
{
    var (name, age) = ("Tom", 23);
    Console.WriteLine(name);    // Tom
    Console.WriteLine(age);     // 23
    Console.Read();
}
В этом случае с полями кортежа мы сможем работать как с переменными, которые определены в рамках метода.
Использование кортежей
Кортежи могут передаваться в качестве параметров в метод, могут быть возвращаемым результатом функции, либо использоваться иным образом.
Например, одной из распространенных ситуаций является возвращение из функции двух и более значений, в то время как функция можно возвращать только одно значение. И кортежи представляют оптимальный способ для решения этой задачи:
1
2
3
4
5
6
7
8
9
10
11
12
13	static void Main(string[] args)
{
    var tuple = GetValues();
    Console.WriteLine(tuple.Item1); // 1
    Console.WriteLine(tuple.Item2); // 3
     
    Console.Read();
}
private static (int, int) GetValues()
{
    var result = (1, 3);
    return result;
}
Здесь определен метод GetValues(), который возвращает кортеж. Кортеж определяется как набор значений, помещенных в круглые скобки. И в данном случае мы возвращаем кортеж из двух элементов типа int, то есть два числа.
Другой пример:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18	static void Main(string[] args)
{
    var tuple = GetNamedValues(new int[]{ 1,2,3,4,5,6,7});
    Console.WriteLine(tuple.count);
    Console.WriteLine(tuple.sum);
     
    Console.Read();
}
private static (int sum, int count) GetNamedValues(int[] numbers)
{
    var result = (sum:0, count: 0);
    for (int i=0; i < numbers.Length; i++)
    {
        result.sum += numbers[i];
        result.count++;
    }
    return result;
}
И также кортеж может передаваться в качестве параметра в метод:
1
2
3
4
5
6
7
8
9
10
11
12
13	static void Main(string[] args)
{
    var (name, age) = GetTuple(("Tom", 23), 12);
    Console.WriteLine(name);    // Tom
    Console.WriteLine(age);     // 35
    Console.Read();
}
         
private static (string name, int age) GetTuple((string n, int a) tuple, int x)
{
    var result = (name: tuple.n, age: tuple.a + x);
    return result;
}
37. Что такое локальная функция

Локальные функции представляют функции, определенные внутри других методов. Локальные функции доступны начиная с версии C# 7.0 (Visual Studio 2017).
Определим и используем локальную функцию:

class Program
{
    static void Main(string[] args)
    {
        var result = GetResult(new int[] { -3, -2, -1, 0, 1, 2, 3 });
        Console.WriteLine(result);  // 6
        Console.Read();
    }
 
    static int GetResult(int[] numbers)
    {
        int limit = 0;
        // локальная функция
        bool IsMoreThan(int number)
        {
            return number > limit;
        }
 
        int result = 0;
        for(int i=0; i < numbers.Length; i++)
        {
            if (IsMoreThan(numbers[i]))
            {
                result += numbers[i];
            }
        }
 
        return result;
    }
}
Здесь в методе GetResult определена локальная функция IsMoreThan(), которая может быть вызвана только внутри этого метода. Локальная функция задает еще одну область видимости, где мы можем определять переменные и выполнять над ними действия. В то же время ей доступны все переменные, которые определены в том же методе.
При использовании локальных функций следует помнить, что они не могут иметь модификаторов доступа (public, private, protected). Нельзя определить в одном методе несколько локальных функций с одним и тем же именем, даже если у них будет разный список параметров. Кроме того, не имеет значения, определены локальные функции до своего вызова или после.
1.	Что такое .Net Framework и из чего он состоит?

.NET Framework — это платформа разработки для создания приложений для Интернета, Windows, Windows Phone, Windows Server и Microsoft Azure. Она состоит из среды CLR и библиотеки классов .NET Framework, которая содержит обширный набор функциональных возможностей, а также обеспечивает поддержку многих отраслевых стандартов.
Платформа .NET Framework предоставляет множество служб, включая управление памятью, безопасность типа и памяти, функции безопасности, работу с сетями и развертывание приложений.Она предоставляет удобные структуры данных и интерфейсы API, которые абстрагируют операционную систему Windows более низкого уровня. В .NET Framework вы можете использовать различные языки программирования, включая C#, F # и Visual Basic.

2. Поясните, что такое CLR-среда.
Common Language Runtime (англ. CLR — общеязыковая исполняющая среда) — исполняющая среда для байт-кода CIL (MSIL), в которой компилируются программы, написанные на .NET-совместимых языках программирования (C#, Managed C++, Visual Basic .NET,F# и прочие). CLR является одним из основных компонентов пакета Microsoft .NET Framework.
Среда CLR является реализацией спецификации CLI (англ. Common Language Infrastructure), спецификации общеязыковой инфраструктуры компании Microsoft.

3. Что такое FCL?
Base Class Library, или так называемая .NET FCL (англ. Framework Class Library), сокращённо BCL — стандартная библиотека классов платформы «.NET Framework». Программы, написанные на любом из языков, поддерживающих платформу .NET, могут пользоваться классами и методами BCL — создавать объекты классов, вызывать их методы, наследовать необходимые классы BCL и т. д.
Стоит отметить, что не все языки, поддерживающие платформу .NET, предоставляют или обязаны предоставлять одинаково полный доступ ко всем классам и всем возможностям BCL — это зависит от особенностей реализации конкретного компилятора и языка.
В отличие от многих других библиотек классов, например, MFC, ATL/WTL или SmartWin, библиотека BCL не является некоей «надстройкой» над функциями операционной системы или над каким-либо API. Библиотеки BCL является органической частью самой платформы .NET Framework, её «родным» API. Её можно рассматривать как API виртуальной машины .NET.
BCL обновляется с каждой версией .NET Framework.


